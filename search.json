[
  {
    "objectID": "randomposts/2025-01-26-react-template/index.html",
    "href": "randomposts/2025-01-26-react-template/index.html",
    "title": "From Python to React: Using Claude Artifacts and ChatGPT Canvas to Build Apps",
    "section": "",
    "text": "As a seasoned Python developer, I‚Äôm used to the comfort of conda environments and the predictability of pip. But lately, I‚Äôve been diving headfirst into the wild world of web development with React. What prompted this shift? The incredible advancements in AI tools like Claude‚Äôs new artifact feature and ChatGPT‚Äôs enhanced support for rendering HTML and React. These tools have made it ridiculously easy to generate React UIs with simple natural language prompts.\nHowever, bridging the gap between AI-generated code and a functional, maintainable application required me to master a new set of tools and concepts. The most pressing challenge? Taming the JavaScript ecosystem. This blog post chronicles my journey, focusing on setting up a solid React template using Vite while navigating the intricacies of Node.js and its package managers.\n\ncreate-react-app does not work; vite does\nMy first instinct was to reach for the familiar create-react-app. Unfortunately, as of January 2025, there are significant issues (see this GitHub issue and many others).\nVite (French for ‚Äúfast‚Äù) is a next-generation build tool that significantly improves the front-end development experience. Here‚Äôs how I set up my React template using Vite:\n\nPrerequisites:\nThis guide assumes a Linux-based system (specifically Ubuntu 24.04 LTS in my case). I‚Äôll update my experiences with Windows later.\n\n\nStep 1: Node.js and the Power of nvm\nBefore diving into Vite, we need Node.js, the runtime environment that allows us to run JavaScript outside of a browser. However, different projects might require different Node.js versions. Here‚Äôs where Node Version Manager (nvm) comes to the rescue.\n\nInstalling nvm: bash     curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.1/install.sh | bash\nInstalling Node.js (LTS): bash     nvm install --lts\n\nnvm allows you to seamlessly switch between Node.js versions using a simple .nvmrc file in your project root, ensuring compatibility across your projects.\n\n\nStep 2: Initializing the React Template with Vite\nWith Node.js in place, creating a React template is a breeze:\nnpm create vite@latest my-react-app\nThis command prompts you to choose a framework (React, Vue, Svelte, etc.) and whether to use JavaScript or TypeScript. I opted for React and JavaScript. You can also use the shorthand: npm create vite@latest my-react-app -- --template react.\n\n\nStep 3: Understanding npm vs.¬†npx\nThroughout this process, you‚Äôll encounter both npm and npx. Here‚Äôs a simple way to distinguish them:\n\nnpm (Node Package Manager): Use it to install packages, either globally or locally within a project.\nnpx (Node Package Execute): Use it to run packages, often one-off tools or generators, without installing them permanently.\n\nFor example, we used npm create vite@latest to initialize our project because create-vite is a tool we might use again. However, for tasks like adding a shadcn component later, we‚Äôll use npx.\n\n\nStep 4: Environment isolation - node_modules Directory\nUnlike Python‚Äôs virtual environments, Node.js relies on a project-specific node_modules directory to store dependencies. This directory can become quite large, but it guarantees that each project has its own isolated set of packages.\nKey Takeaway: Never share node_modules between projects. Always run npm install in a new project clone to populate the node_modules directory based on the package.json and package-lock.json files.\n\n\nStep 5: Embracing tailwindcss and shadcn (with a Caveat)\nModern React development often involves styling libraries like tailwindcss and component libraries like shadcn.\nImportant Note: shadcn is not an npm package but rather a collection of components that you can add to your project. It relies on Radix UI (@radix-ui/react-*) packages for its core functionality.\nIntegrating tailwindcss and shadcn can be tricky due to version conflicts. As of my writing, tailwindcss recently released a major version 4, and shadcn‚Äôs documentation hasn‚Äôt fully caught up.\nMy Solution: I‚Äôve created a public template repository that successfully integrates tailwindcss version 3.4.17 with shadcn. It includes all the necessary configuration changes to the Vite template.\n\n\nStep 6: Organizing Your Code with Components\nFor larger projects, it‚Äôs crucial to structure your code effectively. Instead of dumping everything into src/App.tsx, create a src/components directory for your UI components. You can then import these components into App.tsx. Most LLMs seem to bundle everything in a single App.tsx by default, but you can prompt them to write modular code by separating out the components.\nHere‚Äôs a suggested folder structure:\nmy-react-app/\n‚îú‚îÄ‚îÄ node_modules/\n‚îú‚îÄ‚îÄ public/\n‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îú‚îÄ‚îÄ components/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Interface.tsx # Main UI code\n‚îÇ   ‚îú‚îÄ‚îÄ App.css\n‚îÇ   ‚îú‚îÄ‚îÄ App.tsx         # Import and use your UI components\n‚îÇ   ‚îú‚îÄ‚îÄ index.css\n‚îÇ   ‚îú‚îÄ‚îÄ main.tsx\n‚îÇ   ‚îî‚îÄ‚îÄ vite-env.d.ts\n‚îú‚îÄ‚îÄ index.html\n‚îú‚îÄ‚îÄ package.json\n‚îú‚îÄ‚îÄ package-lock.json\n‚îú‚îÄ‚îÄ tsconfig.json / jsconfig.json\n‚îú‚îÄ‚îÄ tsconfig.node.json\n‚îî‚îÄ‚îÄ vite.config.ts / vite.config.js\n\n\nStep 7: Running Your App\nFinally, to see your app in action, use:\nnpm run dev\nThis starts the Vite development server, typically at localhost:5173 (unlike create-react-app‚Äôs default localhost:3000).\n\n\n\nConclusion: JavaScript Environment Isolation is Great\nThe JavaScript ecosystem can feel daunting at first, especially coming from a Python background. However, with tools like Vite and a clear understanding of Node.js‚Äôs package management, setting up a modern React development environment becomes manageable.\nMy template repository provides a solid starting point, and I encourage you to explore it, adapt it, and contribute to it. As I continue my journey into web development, I‚Äôll keep updating this blog with new insights and discoveries. Stay tuned! Github repository link: https://github.com/fnauman/clip_react\nI hope this comprehensive blog post is helpful! Let me know if you‚Äôd like any adjustments or further details on specific aspects."
  },
  {
    "objectID": "randomposts/2025-02-05-hf-inference/index.html",
    "href": "randomposts/2025-02-05-hf-inference/index.html",
    "title": "Inference on HuggingFace",
    "section": "",
    "text": "HuggingFace just announced that they now support third party inference providers: fal, Replicate, Sambanova, Together AI both directly through the HuggingFace Hub and their SDKs.\nBeing a Pro user of HuggingFace, I get $2 of credits to use each month. So I played around with the Flux model:\nfrom huggingface_hub import InferenceClient\n\nclient = InferenceClient(provider=\"fal-ai\", token=\"hf_***\") # Enable serverless inference when creating the token\n\nimage = client.text_to_image(\"Close-up of a cheetah's face, direct frontal view. Sharp focus on eye and skin texture and color. Natural lighting to capture authentic eye shine and depth.\", model=\"black-forest-labs/FLUX.1-schnell\") \n\nimage.save(\"cheetah.png\")\nThe output looks like this:\n\nThis is fantastic! I can now run quick experiments with many different models on the huggingface hub. There is a text box on the HuggingFace Hub where I can enter text and start generating images (or text for a LLM) easily:\n\nI can even get the code to run this via their Python SDK:\nfrom huggingface_hub import InferenceClient\n\nclient = InferenceClient(\n    provider=\"fal-ai\",\n    api_key=\"hf_xxxxxxxxxxxxxxxxxxxxxxxx\"\n)\n\n# output is a PIL.Image object\nimage = client.text_to_image(\n    \"Astronaut riding a horse\",\n    model=\"black-forest-labs/FLUX.1-dev\"\n)\nThe only challenge I found so far is that fal-ai for example does support the Flux 1.1 pro through their API, but since that model is not available on the HuggingFace Hub, I can‚Äôt use it. I get a ValueError: Model fal-ai/flux-pro/v1 is not supported with FalAI for task text-to-image. error when I try to use it."
  },
  {
    "objectID": "portfolio.html",
    "href": "portfolio.html",
    "title": "Portfolio",
    "section": "",
    "text": "Automating second-hand fashion\n\n\n\n\n\n\nApplied AI\n\n\nSustainable Fashion\n\n\nCircular Economy\n\n\nRISE\n\n\n\nHow can AI be used to accelerate the transition to a circular economy?\n\n\n\n\n\nDec 16, 2023\n\n\nFarrukh Nauman\n\n\n6 min\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/2024-06-15-intelligence-complex/index.html",
    "href": "posts/2024-06-15-intelligence-complex/index.html",
    "title": "Intelligence as a Complex System: Lessons from Physics",
    "section": "",
    "text": "In the rapidly evolving field of artificial intelligence, there‚Äôs a growing need to understand the nuances and complexities of intelligence itself. By drawing analogies from successful physical models of complex systems, we can gain valuable insights into the nature of intelligence and the challenges we face in replicating it. This essay explores the parallels between intelligence and other complex phenomena in physics, highlighting why simplistic approaches to AI may fall short of true artificial general intelligence (AGI).\n\n\n\nJust as physical phenomena exhibit varying degrees of complexity, intelligence exists on a spectrum. Consider the following examples:\n\nTurbulence in fluid dynamics:\n\nSimple: Rayleigh‚ÄìB√©nard convection near the transition point.\nComplex: Plasma behavior around supermassive black holes (Reynolds number \\(\\sim 10^{20}\\)).\n\nIntelligence tasks:\n\nSimple: Grade school math problems.\nComplex: Developing groundbreaking scientific theories (e.g., the Ising model in ferromagnetism).\n\n\nThis spectrum illustrates that, like turbulence, we may not yet know if there‚Äôs an upper limit to intelligence. It also suggests that for many tasks, a simplified or ‚Äúcompressed‚Äù representation might suffice, explaining why some believe AGI has been achieved based on performance in limited domains. The complexity of turbulence is well characterized by the Reynolds number, but studies in the scaling laws of LLMs leaves a lot to be desired where claims of emergence are being made on simple datasets with fixed task complexity, input and output lengths. See Are Emergent Abilities of Large Language Models a Mirage? for a refreshing take on this.\n\n\n\nHistorically, scientists have fallen into the trap of reductionism ‚Äì the belief that complex phenomena can be fully explained by understanding their fundamental components. Paul Dirac‚Äôs 1929 statement exemplifies this:\n\n‚ÄúThe underlying physical laws necessary for the mathematical theory of a large part of physics and the whole of chemistry are thus completely known.‚Äù Source\n\nHowever, just as a unified theory of fundamental forces wouldn‚Äôt explain emergent phenomena in physics, a single AI model is unlikely to capture the full spectrum of intelligence. This reductionist thinking can lead to overestimating the capabilities of current AI models, which excel in specific tasks but struggle with generalization and complex reasoning.\n\n\n\n\nDynamic nature: Intelligence is inherently non-equilibrium, dynamic, nonlinear, and high-dimensional. A static language model, no matter how advanced, cannot fully capture these aspects.\nHierarchical complexity: Like physical systems, intelligence requires flexible frameworks that allow for hierarchical representations. In physics, we have:\n\nN-particle descriptions (e.g., molecular dynamics)\nKinetic descriptions (e.g., Boltzmann, Vlasov equations)\nFluid descriptions (e.g., Navier-Stokes equations)\nMean field descriptions (e.g., filtered turbulent fields)\n\nAI research needs analogous frameworks to capture different levels of cognitive processes. However, one might argue that just like how one can use synthetic turbulence models through stochastic forcing to good effect for modeling unobserved physics across scales, GPT-like models with an analogus stochastic training process might be able to capture higher-level cognitive processes.\nMeta-frameworks for problem-solving: Current AI models lack robust strategies for approaching intractable problems. For instance, when experimental data is scarce or the physical system under consideration is extremely complex, breakthroughs in physics often came from constructing simplified models that capture the essence of complex phenomena (e.g., the Ising model for ferromagnetism).\nData limitations: Current AI models have almost no inductive biases and learn everything from the data, which has limitations:\n\nWeb-scale data has complex reasoning tasks only in their long-tail, which makes complex reasoning difficult to learn.\nDetailed reasoning steps are not available since humans only write down the final answer.\nEqual weighting of data samples is sub-optimal since only a fraction represent high-quality research and content.\nExamples from long-term scientific development are randomly distributed in the data and not systematically organized (e.g., the evolution of theories over decades).\n\nThe specific case of equal weighting of data is particularly problematic since many articles and books are written by people without adequate expertise and contain arguments without rigorous theoretical calculations and experimental results.\n\n\n\n\nDespite these challenges, AI research progresses at an unprecedented rate compared to other complex fields thanks to:\n\nImmediate access to state-of-the-art models through APIs and open-source libraries.\nEnhanced tooling for data ingestion and generation.\nThe ability to build upon existing work rapidly.\n\nContrast this with research in turbulence or computational fluid dynamics, where reproducing results can take years because of:\n\nComplex, million-line codebases in C, C++, Fortran.\nLimited access to high-performance computing.\nLack of open data sharing practices, and detailed model descriptions for reproducibility.\n\nAs an example, consider the difficulty in generating \\(1000\\) time steps for a turbulent flow simulation and contrast it with generating \\(1000\\) tokens in language models through the interface, API or locally hosted models.\n\n\n\nThe very idea of artificial ‚Äúintelligence singularity‚Äù or its opposite is problematic from a scientific perspective where singularities are an indication that our theory is invalid at those scales. The fact that we so readily discuss ‚Äúsingularities‚Äù in the context of intelligence might indicate fundamental limitations in our current models of cognition and AI.\nWhile the rapid progress in AI is exciting, we must approach claims of AGI with caution. By viewing intelligence through the lens of complex systems, we gain a more nuanced understanding of the challenges ahead. Just as physicists continue to grapple with phenomena like turbulence, AI researchers must embrace the multifaceted nature of intelligence, developing new frameworks and approaches to capture its full complexity."
  },
  {
    "objectID": "posts/2024-06-15-intelligence-complex/index.html#introduction",
    "href": "posts/2024-06-15-intelligence-complex/index.html#introduction",
    "title": "Intelligence as a Complex System: Lessons from Physics",
    "section": "",
    "text": "In the rapidly evolving field of artificial intelligence, there‚Äôs a growing need to understand the nuances and complexities of intelligence itself. By drawing analogies from successful physical models of complex systems, we can gain valuable insights into the nature of intelligence and the challenges we face in replicating it. This essay explores the parallels between intelligence and other complex phenomena in physics, highlighting why simplistic approaches to AI may fall short of true artificial general intelligence (AGI)."
  },
  {
    "objectID": "posts/2024-06-15-intelligence-complex/index.html#the-complexity-spectrum",
    "href": "posts/2024-06-15-intelligence-complex/index.html#the-complexity-spectrum",
    "title": "Intelligence as a Complex System: Lessons from Physics",
    "section": "",
    "text": "Just as physical phenomena exhibit varying degrees of complexity, intelligence exists on a spectrum. Consider the following examples:\n\nTurbulence in fluid dynamics:\n\nSimple: Rayleigh‚ÄìB√©nard convection near the transition point.\nComplex: Plasma behavior around supermassive black holes (Reynolds number \\(\\sim 10^{20}\\)).\n\nIntelligence tasks:\n\nSimple: Grade school math problems.\nComplex: Developing groundbreaking scientific theories (e.g., the Ising model in ferromagnetism).\n\n\nThis spectrum illustrates that, like turbulence, we may not yet know if there‚Äôs an upper limit to intelligence. It also suggests that for many tasks, a simplified or ‚Äúcompressed‚Äù representation might suffice, explaining why some believe AGI has been achieved based on performance in limited domains. The complexity of turbulence is well characterized by the Reynolds number, but studies in the scaling laws of LLMs leaves a lot to be desired where claims of emergence are being made on simple datasets with fixed task complexity, input and output lengths. See Are Emergent Abilities of Large Language Models a Mirage? for a refreshing take on this."
  },
  {
    "objectID": "posts/2024-06-15-intelligence-complex/index.html#the-danger-of-hype-reductionist-thinking",
    "href": "posts/2024-06-15-intelligence-complex/index.html#the-danger-of-hype-reductionist-thinking",
    "title": "Intelligence as a Complex System: Lessons from Physics",
    "section": "",
    "text": "Historically, scientists have fallen into the trap of reductionism ‚Äì the belief that complex phenomena can be fully explained by understanding their fundamental components. Paul Dirac‚Äôs 1929 statement exemplifies this:\n\n‚ÄúThe underlying physical laws necessary for the mathematical theory of a large part of physics and the whole of chemistry are thus completely known.‚Äù Source\n\nHowever, just as a unified theory of fundamental forces wouldn‚Äôt explain emergent phenomena in physics, a single AI model is unlikely to capture the full spectrum of intelligence. This reductionist thinking can lead to overestimating the capabilities of current AI models, which excel in specific tasks but struggle with generalization and complex reasoning."
  },
  {
    "objectID": "posts/2024-06-15-intelligence-complex/index.html#key-aspects-of-intelligence-as-a-complex-system",
    "href": "posts/2024-06-15-intelligence-complex/index.html#key-aspects-of-intelligence-as-a-complex-system",
    "title": "Intelligence as a Complex System: Lessons from Physics",
    "section": "",
    "text": "Dynamic nature: Intelligence is inherently non-equilibrium, dynamic, nonlinear, and high-dimensional. A static language model, no matter how advanced, cannot fully capture these aspects.\nHierarchical complexity: Like physical systems, intelligence requires flexible frameworks that allow for hierarchical representations. In physics, we have:\n\nN-particle descriptions (e.g., molecular dynamics)\nKinetic descriptions (e.g., Boltzmann, Vlasov equations)\nFluid descriptions (e.g., Navier-Stokes equations)\nMean field descriptions (e.g., filtered turbulent fields)\n\nAI research needs analogous frameworks to capture different levels of cognitive processes. However, one might argue that just like how one can use synthetic turbulence models through stochastic forcing to good effect for modeling unobserved physics across scales, GPT-like models with an analogus stochastic training process might be able to capture higher-level cognitive processes.\nMeta-frameworks for problem-solving: Current AI models lack robust strategies for approaching intractable problems. For instance, when experimental data is scarce or the physical system under consideration is extremely complex, breakthroughs in physics often came from constructing simplified models that capture the essence of complex phenomena (e.g., the Ising model for ferromagnetism).\nData limitations: Current AI models have almost no inductive biases and learn everything from the data, which has limitations:\n\nWeb-scale data has complex reasoning tasks only in their long-tail, which makes complex reasoning difficult to learn.\nDetailed reasoning steps are not available since humans only write down the final answer.\nEqual weighting of data samples is sub-optimal since only a fraction represent high-quality research and content.\nExamples from long-term scientific development are randomly distributed in the data and not systematically organized (e.g., the evolution of theories over decades).\n\nThe specific case of equal weighting of data is particularly problematic since many articles and books are written by people without adequate expertise and contain arguments without rigorous theoretical calculations and experimental results."
  },
  {
    "objectID": "posts/2024-06-15-intelligence-complex/index.html#the-unique-pace-of-ai-development",
    "href": "posts/2024-06-15-intelligence-complex/index.html#the-unique-pace-of-ai-development",
    "title": "Intelligence as a Complex System: Lessons from Physics",
    "section": "",
    "text": "Despite these challenges, AI research progresses at an unprecedented rate compared to other complex fields thanks to:\n\nImmediate access to state-of-the-art models through APIs and open-source libraries.\nEnhanced tooling for data ingestion and generation.\nThe ability to build upon existing work rapidly.\n\nContrast this with research in turbulence or computational fluid dynamics, where reproducing results can take years because of:\n\nComplex, million-line codebases in C, C++, Fortran.\nLimited access to high-performance computing.\nLack of open data sharing practices, and detailed model descriptions for reproducibility.\n\nAs an example, consider the difficulty in generating \\(1000\\) time steps for a turbulent flow simulation and contrast it with generating \\(1000\\) tokens in language models through the interface, API or locally hosted models."
  },
  {
    "objectID": "posts/2024-06-15-intelligence-complex/index.html#conclusion",
    "href": "posts/2024-06-15-intelligence-complex/index.html#conclusion",
    "title": "Intelligence as a Complex System: Lessons from Physics",
    "section": "",
    "text": "The very idea of artificial ‚Äúintelligence singularity‚Äù or its opposite is problematic from a scientific perspective where singularities are an indication that our theory is invalid at those scales. The fact that we so readily discuss ‚Äúsingularities‚Äù in the context of intelligence might indicate fundamental limitations in our current models of cognition and AI.\nWhile the rapid progress in AI is exciting, we must approach claims of AGI with caution. By viewing intelligence through the lens of complex systems, we gain a more nuanced understanding of the challenges ahead. Just as physicists continue to grapple with phenomena like turbulence, AI researchers must embrace the multifaceted nature of intelligence, developing new frameworks and approaches to capture its full complexity."
  },
  {
    "objectID": "randomposts.html",
    "href": "randomposts.html",
    "title": "TIL/Random Notes",
    "section": "",
    "text": "This is a collection of random thoughts and things I‚Äôve learned. This often reflects a work in progress, and I may update posts as I learn more.\n\n\n\n\n\n\n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nInference on HuggingFace\n\n\n\n\n\n\nhuggingface\n\n\ninference\n\n\ntext-to-image\n\n\nflux\n\n\n\nPlaying with the Inference Providers on HuggingFace\n\n\n\n\n\nFeb 5, 2025\n\n\n2 min\n\n\n\n\n\n\n\n\n\n\n\n\nUploading datasets to Hugging Face\n\n\n\n\n\n\nhuggingface\n\n\ndatasets\n\n\n\nHugging Face Datasets and Datasets Hub\n\n\n\n\n\nJan 26, 2025\n\n\n2 min\n\n\n\n\n\n\n\n\n\n\n\n\nFrom Python to React: Using Claude Artifacts and ChatGPT Canvas to Build Apps\n\n\n\n\n\n\nweb development\n\n\nreact\n\n\njavascript\n\n\nnodejs\n\n\napps\n\n\n\nLearn how to set up a modern web development environment: React, Node.js, and Vite.\n\n\n\n\n\nJan 26, 2025\n\n\n5 min\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "portfolio/2023-12-16-second-hand-fashion/index.html",
    "href": "portfolio/2023-12-16-second-hand-fashion/index.html",
    "title": "Automating second-hand fashion",
    "section": "",
    "text": "Note\n\n\n\nUpdate February 2025: For more detailed and up-to-date information, please visit fnauman.github.io/second-hand-fashion."
  },
  {
    "objectID": "portfolio/2023-12-16-second-hand-fashion/index.html#ai-in-the-fashion-industry",
    "href": "portfolio/2023-12-16-second-hand-fashion/index.html#ai-in-the-fashion-industry",
    "title": "Automating second-hand fashion",
    "section": "AI in the Fashion Industry",
    "text": "AI in the Fashion Industry\nAI has been used in many applications in the fashion industry including product recommendation, visual search, virtual try-on, and trend forecasting. Second-hand fashion, on the other hand, remains almost exclusively manual. The sorting and grading of second-hand clothing is a labor-intensive process that requires a lot of time and effort. The lack of automation in this sector is a major bottleneck in the transition to a circular economy.\nI am fortunate to be involved in two large projects aiming to automate the second-hand fashion industry. The first project is AI for Resource-Efficient Circular Fashion funded by the Swedish Innovation Agency, Vinnova. The second project is funded by the EU: Increasing Circularity and Sustainability in Textiles and Clothing in Europe."
  },
  {
    "objectID": "portfolio/2023-12-16-second-hand-fashion/index.html#sorting",
    "href": "portfolio/2023-12-16-second-hand-fashion/index.html#sorting",
    "title": "Automating second-hand fashion",
    "section": "Sorting",
    "text": "Sorting\nSorting is a multi-step process that involves the following steps:\n\nPre-sorting: Separate shoes, household textiles like bedsheets and curtains, and other non-fashion items from the fashion items.\nSorting fashion clothes [THIS PROJECT]: Predict various attributes of the clothing items and sort them for:\n\nReuse: Items that are in good condition and can be sold as-is. Reuse is the most sustainable option and has further sub-categories:\n\nSell in Sweden.\nSell outside Sweden or export.\n\nRepair: Items in need of repairs, but are otherwise reusable.\nRecycle: Items made of recyclable materials like 100% cotton.\nLandfill: Items that are in extremely poor condition and cannot be reused or recycled.\n\nFine sorting: This is the sorting that is most relevant to second-hand retailers that sell in-store and online. Their goal is to take the chunk of reusable clothing items and then decide which items to sell at what price and in what location. We do not address this in our project directly although our sorting model can be used to support this process.\n\nIn addition to this, clothes must be handled manually when they first arrive at the facility in large containers. Currently, no known technology exists that can fully automate this step although exciting advances in the field of robotics are being made."
  },
  {
    "objectID": "portfolio/2023-12-16-second-hand-fashion/index.html#ai-powered-sorting",
    "href": "portfolio/2023-12-16-second-hand-fashion/index.html#ai-powered-sorting",
    "title": "Automating second-hand fashion",
    "section": "AI-Powered Sorting",
    "text": "AI-Powered Sorting\nThe first major challenge that any project aiming to automate the second-hand fashion industry faces is the lack of data. Existing ‚Äúfoundation AI models‚Äù are largely biased towards first-hand fashion since that is the kind of data that is readily available on the internet. For instance, these models are incapable of recognizing the wear and tear of second-hand clothing since first-hand fashion images are usually of pristine quality.\nIn the Vinnova project that I am leading from RISE, we are developing a novel dataset with 30,000 used clothing items in partnership with Warg√∂n Innovation. The first version of the dataset has already been released:\n\nDataset v1, 3000 clothing items: Zenodo link.\n\n\n\n\n\n\n\nImportant\n\n\n\nUpdate February 2025: v3 with 31,638 items was released on September 19th, 2024 here. For up to date information, please visit fnauman.github.io/second-hand-fashion.\n\n\nThe dataset has been released under a permissive CC-BY 4.0 license that allows commercial use given that the authors are properly cited.\nFurthermore, we are developing AI models to recognize damage on clothes and to grade them according to their quality. The scope of ongoing projects is not full automation, but to instead provide a ‚Äúdecision support tool‚Äù. A decision support tool is supposed to assist the human operator in making the final decision by judging the cloth condition, assessing the brand quality and how it compares with other brands in the market, and finally, estimating the best use case for the item."
  },
  {
    "objectID": "portfolio/2023-12-16-second-hand-fashion/index.html#challenges-and-opportunities",
    "href": "portfolio/2023-12-16-second-hand-fashion/index.html#challenges-and-opportunities",
    "title": "Automating second-hand fashion",
    "section": "Challenges and Opportunities",
    "text": "Challenges and Opportunities\nWe have identified the following challenges and opportunities in the second-hand fashion industry:\n\nData: While our dataset of 30,000 clothing items is the largest of its kind, it is still not large enough to train a deep learning model of the ‚Äúfoundation model‚Äù kind. Instead, we must resort to using existing foundation models and finetune them with this data. What makes this particularly challenging is that for first-hand fashion, training a model on, for example, pink T-shirts and black pants is sufficient, but for second-hand fashion, one must be able to distinguish between a pink T-shirt that is in good condition and one that is in poor condition. In other words, we need a dataset large enough to contain different degrees of damage to clothes. One major problem with lack of data will be addressed by the introduction of the digital product passport that aims to preserve the data about a product throughout its life cycle.\nAnnotations: Similar to the subjectivity of language annotations, the annotations of second-hand clothing items are often specific to the annotators and the scope of the facility they are working for. For instance, Warg√∂n Innovation works with the Swedish Red Cross and does not directly price the clothing items. In contrast, other sorting facilities like Myrorna and Bj√∂rk√•frihet price the items to be sold in their own stores. This means that the annotations are not only subjective, but also specific to the business model of the sorting facility.\nRobotics: The second-hand fashion industry is still almost exclusively manual. With the recent advances in robotics, there is an exciting opportunity to fully automate the entire sorting process from the pre-sorting step to the fine sorting step."
  },
  {
    "objectID": "portfolio/2023-12-16-second-hand-fashion/index.html#conclusion",
    "href": "portfolio/2023-12-16-second-hand-fashion/index.html#conclusion",
    "title": "Automating second-hand fashion",
    "section": "Conclusion",
    "text": "Conclusion\nThe second-hand fashion industry is ripe for disruption. With the increase in global awareness about the environmental impact of the textile industry, the second-hand fashion retail is expected to grow exponentially. Nonetheless, the industry is still largely manual and lacks large scale datasets and AI models. The introduction of the digital product passport and extended producer responsibility are likely to accelerate the automation of the second-hand fashion industry. Most players in this sector are volunteer run small businesses that lack the resources to invest in AI and robotics. With project like ours, we hope to make the technology accessible to all players."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Farrukh Nauman",
    "section": "",
    "text": "I‚Äôm an AI Researcher and Machine Learning Consultant at RISE Research Institutes of Sweden AB with a PhD in Theoretical and Computational Astrophysics. I specialize in:\n\nü§ñ Large Language Models (LLMs) for research and industry applications\nüîç Computer Vision & Object Detection\nüìà Time Series Analysis & Forecasting\nüåä Fluid Dynamics (CFD, Modeling, Machine Learning)\n\nMy work spans both research and practical applications, from implementing LLMs for research report generation to developing object detection systems for the agricultural sector. I‚Äôm particularly passionate about bridging the gap between cutting-edge AI research and real-world industry applications.\n\n\n\n\n\n\nü§ù Available for Consulting\n\n\n\n\n\n\n\n\n\n\nEmail me\n\n\n\n\n\n\n\n\n\nIntelligence as a Complex System: Lessons from Physics - June 15, 2024\nLarge Language Models: A Compact Guide - November 20, 2023\n\nView all posts ‚Üí\n\n\n\n\nInference on HuggingFace - February 05, 2025\nUploading datasets to Hugging Face - January 26, 2025\nFrom Python to React: Using Claude Artifacts and ChatGPT Canvas to Build Apps - January 26, 2025\n\nView all TIL posts ‚Üí\n\n\n\n\n\n\n\n\nAI-powered solutions for sustainable fashion, including multi-target classification and damage detection.\n\n\n\nDeveloping custom LLM solutions for automated research report generation and analysis.\n\n\n\nComputer vision systems for farming applications.\n\n\nView full portfolio ‚Üí"
  },
  {
    "objectID": "index.html#recent-updates",
    "href": "index.html#recent-updates",
    "title": "Farrukh Nauman",
    "section": "",
    "text": "Intelligence as a Complex System: Lessons from Physics - June 15, 2024\nLarge Language Models: A Compact Guide - November 20, 2023\n\nView all posts ‚Üí\n\n\n\n\nInference on HuggingFace - February 05, 2025\nUploading datasets to Hugging Face - January 26, 2025\nFrom Python to React: Using Claude Artifacts and ChatGPT Canvas to Build Apps - January 26, 2025\n\nView all TIL posts ‚Üí"
  },
  {
    "objectID": "index.html#featured-projects",
    "href": "index.html#featured-projects",
    "title": "Farrukh Nauman",
    "section": "",
    "text": "AI-powered solutions for sustainable fashion, including multi-target classification and damage detection.\n\n\n\nDeveloping custom LLM solutions for automated research report generation and analysis.\n\n\n\nComputer vision systems for farming applications.\n\n\nView full portfolio ‚Üí"
  },
  {
    "objectID": "posts/2023-11-20-llms-summary/index.html",
    "href": "posts/2023-11-20-llms-summary/index.html",
    "title": "Large Language Models: A Compact Guide",
    "section": "",
    "text": "Best models and tools I use as of Jan.¬†20th, 2025:\n\nCode: Claude 3.5 Sonnet (also hearing a lot about DeepSeek-r1 and DeekSeekv3 - 93.1% of aider‚Äôs own code writes are using Deepseekv3)\nWriting: Gemini 2.0 Experimental 1206 - this has become my primary model for most use cases, but unfortunately currently only supports file attachments through AI studio interface, not the Gemini app.\nAudio: OpenAI‚Äôs GPT-4o, Gemini 2.0 Flash - both seem to have a 30 min limit unfortunately.\nPlanning: o1 by Open AI (with some input by Claude and Gemini).\nResearch: NotebookLM, Gemini Deep Research (mostly human-in-the-loop workflows where I write custom prompts, sources, etc.).\nIDEs: Windsurf, VSCode with Copilot\n\n\nThis guide provides a technical introduction to modern Large Language Models (LLMs) targeted at academics and software engineers who are beginning to explore this exciting field. LLMs can be leveraged in various applications, such as content generation, code assistance, data analysis, and more. While this is a concise overview, it should serve as a solid starting point for anyone interested in grasping the fundamentals of LLMs and their potential. I intend to continually update this guide with the latest advancements and insights in the field.\n\n\nAt their core, Language Models are designed to learn the probability distribution of word sequences. In the realm of deep learning, modern LLMs typically comprise the following essential components:\n\n\nBefore text can be processed by an LLM, it must be converted into numerical representations. This is the role of the tokenizer. Tokenizers break down text into smaller units called tokens, which can be words, subwords, or characters. Different LLMs often employ distinct tokenization methods, leading to fragmentation in the ecosystem. For example, OpenAI models utilize Byte-Pair Encoding (BPE), while T5 uses SentencePiece.\nTokenization as a Potential Bottleneck: Tokenization can be a performance bottleneck and introduce limitations, particularly in these scenarios:\n\nVocabulary Size and Out-of-Vocabulary (OOV) Tokens: Tokenizers typically have a fixed vocabulary size. Words not present in this vocabulary are treated as OOV tokens, often represented by a special &lt;unk&gt; token. A high number of OOV tokens can degrade model performance as the model has no learned representation for these words.\nAdaptability to New Languages: Models trained primarily on English may struggle to tokenize languages with different scripts or linguistic structures (e.g., Chinese, Urdu, Swahili). This is because their tokenizer vocabularies are optimized for English.\nDomain-Specific Languages: Technical domains like programming languages (HTML, Python) or specialized fields (medicine, law) pose challenges. These domains have unique syntax, terminology, and structures that general-purpose tokenizers may not handle optimally. For instance, the tokenization of code often needs to preserve whitespace and special characters that have semantic meaning.\n\nUnderstanding tokenizer limitations is crucial when applying LLMs to diverse languages or specialized domains. Libraries like Hugging Face tokenizers offer tools to explore different tokenization algorithms and even train custom tokenizers for specific needs.\n\n\n\nThe numerical tokens are then transformed into dense vector representations by a learned embedding layer. These embeddings are not just arbitrary numbers; they are designed to capture the semantic meaning of the tokens. Tokens with similar meanings are positioned closer together in the embedding space. The size of the embedding vector (embedding dimension) is a hyperparameter, with modern LLMs often employing sizes of 2048 or larger.\nPurpose of Embeddings: Embeddings serve as a crucial bridge, translating discrete tokens into a continuous vector space where semantic relationships can be mathematically modeled. Pre-trained LLMs leverage embeddings learned from vast amounts of text data, enabling them to capture general language understanding. Larger embedding dimensions can potentially represent more nuanced semantic information, but also increase model complexity and computational demands.\n\n\n\nThe self-attention mechanism is arguably the most significant innovation driving the power of modern LLMs. It allows each token in a sequence to ‚Äúattend‚Äù to all other tokens, enabling the model to capture contextual relationships within the input. This is in contrast to earlier sequential models (like RNNs) which processed text token by token.\nHow Self-Attention Works (Simplified): Imagine each token as having three vectors associated with it: a Query, a Key, and a Value. For each token, the model calculates an ‚Äúattention score‚Äù by comparing its Query vector to the Key vectors of all other tokens in the sequence. These scores determine how much attention each token should pay to others when constructing its contextual representation. The Value vectors are then weighted by these attention scores and aggregated to produce the context-aware representation for each token.\nMultiple Attention Heads: Most LLMs utilize multi-head attention, meaning they perform the self-attention process multiple times in parallel with different sets of Query, Key, and Value matrices. This allows the model to learn diverse types of relationships and attend to different aspects of the input simultaneously, enriching the contextual understanding.\nComputational Considerations: It‚Äôs important to note that the computational complexity of self-attention is quadratic with respect to the sequence length (O(n2)), where n is the number of tokens. This can become a bottleneck for very long sequences, prompting research into more efficient attention mechanisms.\n\n\n\nModern LLM architectures, primarily based on decoder-only Transformers, also incorporate other layers such as Layer Normalization (LayerNorm) and activation functions like GeLU (Gaussian Error Linear Unit). While their precise theoretical underpinnings are still being researched, empirically, these components play a crucial role in stabilizing the training process and improving model performance.\n\n\n\n\n\nTraining a high-performing LLM is a multi-stage process, drawing upon principles from self-supervised learning, supervised learning, and reinforcement learning. The typical training pipeline involves:\n\n\nThis is the most computationally intensive stage, involving training the model on trillions of tokens of text data. The objective is self-supervised learning, where the model learns to predict masked words (for encoder models) or the next word in a sequence (for decoder models).\nData and Objective: Pretraining data is typically a diverse mix of text from the web, books, code repositories, and scientific articles. The data is often used ‚Äúas is,‚Äù but increasingly, pretraining datasets are structured in a ‚Äútask-response‚Äù format, similar to instruction tuning, to improve downstream task performance. The goal is to learn general language representations and a broad understanding of the world from this massive dataset.\nImportance: Pretraining equips the model with fundamental language capabilities and a vast amount of world knowledge, forming the foundation for subsequent fine-tuning stages.\n\n\n\nIn this stage, the pretrained model is further trained on a smaller dataset of millions of tokens with supervised learning. The focus shifts to aligning the model‚Äôs general language capabilities with the ability to follow instructions and perform specific tasks.\nData and Objective: Instruction tuning datasets consist of examples in a ‚Äúinstruction-response‚Äù format, covering a wide range of tasks like question answering, summarization, essay writing, code generation, and more. The data mixture is crucial. Training on a diverse and high-quality instruction dataset leads to models that generalize well across various tasks. A model heavily trained on code tasks, for example, might perform poorly on essay writing if not exposed to sufficient writing-related instructions.\nImportance: Instruction tuning teaches the model to understand and execute instructions, making it more useful for practical applications where users provide specific prompts or task descriptions.\n\n\n\nFor tasks where output quality is subjective or difficult to define objectively (e.g., essay quality, helpfulness of a chatbot response), Reinforcement Learning from Human Feedback (RLHF) is often employed.\nData and Objective: RLHF utilizes human preference data. Humans are presented with pairs of model-generated outputs for the same prompt and asked to choose the preferred output. This preference data is then used to train a reward model, which learns to predict human preferences. Subsequently, reinforcement learning algorithms (like Proximal Policy Optimization - PPO) are used to fine-tune the LLM to maximize the reward predicted by the reward model.\nImportance: RLHF helps align the model‚Äôs behavior with human values and preferences, improving the quality, helpfulness, and safety of generated text. It addresses subjective aspects of language quality that are difficult to capture with purely supervised learning objectives.\n\n\n\nSome advanced models, like OpenAI‚Äôs o1 or DeepSeek‚Äôs r1 reasoning models, incorporate additional reinforcement learning stages focused on improving reasoning abilities. While the exact details on how OpenAI trained their ‚Äúo‚Äù series of models are hidden and proprietary, the speculation is that it could include test time search, process reward modeling, chain-of-thought based supervised finetuning, and more. DeepSeek‚Äôs r1-zero model does not use supervised finetuning at all and relies on verifable (or ‚Äúrule-based‚Äù) rewards for training. Their r1 model, however, uses a combination of supervised finetuning, RLHF and verifiable rewards. The most fascinating thing about DeepSeek‚Äôs r1 model is reflection or backtracking, where the model can reflect on its own reasoning process and correct itself if it finds a mistake. According to the authors, this emerged during training and was not explicitly programmed into the model.\nData and Objective: The data for verifable rewards is mostly restricted to domains like math and code.\n\nImportance: Reinforcement finetuning for reasoning is a frontier in LLM training with multiple labs trying to understand how best to scale reasoning capabilities.\n\n\n\n\nDespite their impressive capabilities, LLMs have inherent limitations that are crucial to consider when designing applications.\n\n\nLLMs can exhibit prompt sensitivity. Slight variations in prompt phrasing, even while maintaining semantic meaning, can sometimes lead to surprisingly different model outputs. This stochastic nature, combined with the opacity of the training data, makes it challenging to predict model behavior consistently.\nImplications for Applications: Prompt sensitivity poses challenges for building reliable and predictable applications, especially in agentic systems where LLMs make decisions on behalf of users. Inconsistent outputs can undermine user trust and application stability.\nMitigation Strategies:\n\nPrompt Engineering Best Practices: Employing structured prompt formats, clear instructions, adding examples (few shot prompting), chain-of-thought, and consistent phrasing can improve prompt robustness.\nPrompt Testing and Selection: Systematically testing a range of prompts and selecting those that yield the most consistent and desired outputs for a given task. Many ‚Äúobservability‚Äù tools like wandb weave, arize phoenix, langsmith, and claude‚Äôs prompt tuner tools are available to help with this.\nEnsemble Methods: Combining outputs from multiple prompts or model instances can potentially reduce variance and improve robustness, but at a cost.\n\n\n\n\nLLMs can exhibit limited self-improvement. They may repeat the same mistakes or biases without fundamentally learning from their errors in an iterative manner. While models like OpenAI‚Äôs o1 and Claude 3.5 Sonnet demonstrate improved self-correction, particularly in code-related tasks, general self-improvement remains a significant challenge.\n\n\n\nLLMs primarily learn statistical correlations from massive datasets. While they can exhibit impressive ‚Äúknowledge,‚Äù they often lack true ‚Äúunderstanding‚Äù of underlying concepts and causal relationships.\nCounterfactual Reasoning Failures: When tested on counterfactual puzzles or questions that require reasoning about ‚Äúwhat if‚Äù scenarios or understanding causal mechanisms, LLMs often perform poorly. This highlights their reliance on memorized patterns rather than genuine conceptual understanding.\n\n\n\n\nGeneral-purpose LLMs are trained on broad internet datasets. Many specialized domains, such as medicine, law, or specific technical fields, have their own extensive vocabularies, jargon, and conceptual frameworks that are not adequately represented in general language models.\nDomain-Specific Model Requirements: Effective application of LLMs in specialized domains often necessitates:\n\nDomain-Specific Fine-tuning: Further training general LLMs on domain-specific data to adapt their vocabulary and knowledge.\nSpecialized Models: Developing LLMs trained specifically for a particular domain from the outset.\nVocabulary Extension Techniques: Methods to expand the tokenizer vocabulary to include domain-specific terms.\nKnowledge Augmentation: Integrating LLMs with domain-specific knowledge bases or retrieval systems.\n\nConcepts and ideas that appear infrequently in the training data (the ‚Äúlong tail‚Äù of the knowledge distribution) are less likely to be learned effectively by LLMs. While Retrieval-Augmented Generation (RAG) can provide LLMs with relevant context from external knowledge sources, it is not a complete solution for long-tail knowledge. Generating high-quality text about rare or novel concepts may require more ‚Äúcore‚Äù knowledge and reasoning ability than the model possesses, even with retrieved context.\nChallenges for Niche Applications: Applications dealing with highly specialized or niche topics may encounter limitations due to the model‚Äôs lack of familiarity with long-tail concepts.\n\n\n\n\nThis introduction has provided a foundational understanding of Large Language Models. To further your exploration and begin applying LLMs in your projects, consider the following steps:\n\nExplore the Hugging Face Transformers Library: A powerful and user-friendly library for working with pre-trained LLMs in Python. Experiment with different models, tokenizers, and prompting techniques.\nDive into Prompt Engineering: Learn effective prompt engineering strategies to guide LLMs to generate desired outputs. Online resources and courses dedicated to prompt engineering are readily available.\nExperiment with LLM APIs: Utilize APIs from providers like OpenAI, Google, and Anthropic to access and experiment with state-of-the-art LLMs without needing to train or host models yourself.\nInvestigate LLM Application Frameworks: Explore frameworks like LangChain and LlamaIndex that simplify the process of building complex applications with LLMs, including RAG, agents, and more.\nStay Updated with Research: The field of LLMs is rapidly evolving. Follow research publications, blogs, and communities to stay abreast of the latest advancements and emerging techniques.\n\nBy taking these steps, you can move beyond theoretical understanding and begin to practically leverage the power of Large Language Models in your academic research, software development, and beyond."
  },
  {
    "objectID": "posts/2023-11-20-llms-summary/index.html#update",
    "href": "posts/2023-11-20-llms-summary/index.html#update",
    "title": "Large Language Models: A Compact Guide",
    "section": "",
    "text": "Best models and tools I use as of Jan.¬†20th, 2025:\n\nCode: Claude 3.5 Sonnet (also hearing a lot about DeepSeek-r1 and DeekSeekv3 - 93.1% of aider‚Äôs own code writes are using Deepseekv3)\nWriting: Gemini 2.0 Experimental 1206 - this has become my primary model for most use cases, but unfortunately currently only supports file attachments through AI studio interface, not the Gemini app.\nAudio: OpenAI‚Äôs GPT-4o, Gemini 2.0 Flash - both seem to have a 30 min limit unfortunately.\nPlanning: o1 by Open AI (with some input by Claude and Gemini).\nResearch: NotebookLM, Gemini Deep Research (mostly human-in-the-loop workflows where I write custom prompts, sources, etc.).\nIDEs: Windsurf, VSCode with Copilot\n\n\nThis guide provides a technical introduction to modern Large Language Models (LLMs) targeted at academics and software engineers who are beginning to explore this exciting field. LLMs can be leveraged in various applications, such as content generation, code assistance, data analysis, and more. While this is a concise overview, it should serve as a solid starting point for anyone interested in grasping the fundamentals of LLMs and their potential. I intend to continually update this guide with the latest advancements and insights in the field.\n\n\nAt their core, Language Models are designed to learn the probability distribution of word sequences. In the realm of deep learning, modern LLMs typically comprise the following essential components:\n\n\nBefore text can be processed by an LLM, it must be converted into numerical representations. This is the role of the tokenizer. Tokenizers break down text into smaller units called tokens, which can be words, subwords, or characters. Different LLMs often employ distinct tokenization methods, leading to fragmentation in the ecosystem. For example, OpenAI models utilize Byte-Pair Encoding (BPE), while T5 uses SentencePiece.\nTokenization as a Potential Bottleneck: Tokenization can be a performance bottleneck and introduce limitations, particularly in these scenarios:\n\nVocabulary Size and Out-of-Vocabulary (OOV) Tokens: Tokenizers typically have a fixed vocabulary size. Words not present in this vocabulary are treated as OOV tokens, often represented by a special &lt;unk&gt; token. A high number of OOV tokens can degrade model performance as the model has no learned representation for these words.\nAdaptability to New Languages: Models trained primarily on English may struggle to tokenize languages with different scripts or linguistic structures (e.g., Chinese, Urdu, Swahili). This is because their tokenizer vocabularies are optimized for English.\nDomain-Specific Languages: Technical domains like programming languages (HTML, Python) or specialized fields (medicine, law) pose challenges. These domains have unique syntax, terminology, and structures that general-purpose tokenizers may not handle optimally. For instance, the tokenization of code often needs to preserve whitespace and special characters that have semantic meaning.\n\nUnderstanding tokenizer limitations is crucial when applying LLMs to diverse languages or specialized domains. Libraries like Hugging Face tokenizers offer tools to explore different tokenization algorithms and even train custom tokenizers for specific needs.\n\n\n\nThe numerical tokens are then transformed into dense vector representations by a learned embedding layer. These embeddings are not just arbitrary numbers; they are designed to capture the semantic meaning of the tokens. Tokens with similar meanings are positioned closer together in the embedding space. The size of the embedding vector (embedding dimension) is a hyperparameter, with modern LLMs often employing sizes of 2048 or larger.\nPurpose of Embeddings: Embeddings serve as a crucial bridge, translating discrete tokens into a continuous vector space where semantic relationships can be mathematically modeled. Pre-trained LLMs leverage embeddings learned from vast amounts of text data, enabling them to capture general language understanding. Larger embedding dimensions can potentially represent more nuanced semantic information, but also increase model complexity and computational demands.\n\n\n\nThe self-attention mechanism is arguably the most significant innovation driving the power of modern LLMs. It allows each token in a sequence to ‚Äúattend‚Äù to all other tokens, enabling the model to capture contextual relationships within the input. This is in contrast to earlier sequential models (like RNNs) which processed text token by token.\nHow Self-Attention Works (Simplified): Imagine each token as having three vectors associated with it: a Query, a Key, and a Value. For each token, the model calculates an ‚Äúattention score‚Äù by comparing its Query vector to the Key vectors of all other tokens in the sequence. These scores determine how much attention each token should pay to others when constructing its contextual representation. The Value vectors are then weighted by these attention scores and aggregated to produce the context-aware representation for each token.\nMultiple Attention Heads: Most LLMs utilize multi-head attention, meaning they perform the self-attention process multiple times in parallel with different sets of Query, Key, and Value matrices. This allows the model to learn diverse types of relationships and attend to different aspects of the input simultaneously, enriching the contextual understanding.\nComputational Considerations: It‚Äôs important to note that the computational complexity of self-attention is quadratic with respect to the sequence length (O(n2)), where n is the number of tokens. This can become a bottleneck for very long sequences, prompting research into more efficient attention mechanisms.\n\n\n\nModern LLM architectures, primarily based on decoder-only Transformers, also incorporate other layers such as Layer Normalization (LayerNorm) and activation functions like GeLU (Gaussian Error Linear Unit). While their precise theoretical underpinnings are still being researched, empirically, these components play a crucial role in stabilizing the training process and improving model performance.\n\n\n\n\n\nTraining a high-performing LLM is a multi-stage process, drawing upon principles from self-supervised learning, supervised learning, and reinforcement learning. The typical training pipeline involves:\n\n\nThis is the most computationally intensive stage, involving training the model on trillions of tokens of text data. The objective is self-supervised learning, where the model learns to predict masked words (for encoder models) or the next word in a sequence (for decoder models).\nData and Objective: Pretraining data is typically a diverse mix of text from the web, books, code repositories, and scientific articles. The data is often used ‚Äúas is,‚Äù but increasingly, pretraining datasets are structured in a ‚Äútask-response‚Äù format, similar to instruction tuning, to improve downstream task performance. The goal is to learn general language representations and a broad understanding of the world from this massive dataset.\nImportance: Pretraining equips the model with fundamental language capabilities and a vast amount of world knowledge, forming the foundation for subsequent fine-tuning stages.\n\n\n\nIn this stage, the pretrained model is further trained on a smaller dataset of millions of tokens with supervised learning. The focus shifts to aligning the model‚Äôs general language capabilities with the ability to follow instructions and perform specific tasks.\nData and Objective: Instruction tuning datasets consist of examples in a ‚Äúinstruction-response‚Äù format, covering a wide range of tasks like question answering, summarization, essay writing, code generation, and more. The data mixture is crucial. Training on a diverse and high-quality instruction dataset leads to models that generalize well across various tasks. A model heavily trained on code tasks, for example, might perform poorly on essay writing if not exposed to sufficient writing-related instructions.\nImportance: Instruction tuning teaches the model to understand and execute instructions, making it more useful for practical applications where users provide specific prompts or task descriptions.\n\n\n\nFor tasks where output quality is subjective or difficult to define objectively (e.g., essay quality, helpfulness of a chatbot response), Reinforcement Learning from Human Feedback (RLHF) is often employed.\nData and Objective: RLHF utilizes human preference data. Humans are presented with pairs of model-generated outputs for the same prompt and asked to choose the preferred output. This preference data is then used to train a reward model, which learns to predict human preferences. Subsequently, reinforcement learning algorithms (like Proximal Policy Optimization - PPO) are used to fine-tune the LLM to maximize the reward predicted by the reward model.\nImportance: RLHF helps align the model‚Äôs behavior with human values and preferences, improving the quality, helpfulness, and safety of generated text. It addresses subjective aspects of language quality that are difficult to capture with purely supervised learning objectives.\n\n\n\nSome advanced models, like OpenAI‚Äôs o1 or DeepSeek‚Äôs r1 reasoning models, incorporate additional reinforcement learning stages focused on improving reasoning abilities. While the exact details on how OpenAI trained their ‚Äúo‚Äù series of models are hidden and proprietary, the speculation is that it could include test time search, process reward modeling, chain-of-thought based supervised finetuning, and more. DeepSeek‚Äôs r1-zero model does not use supervised finetuning at all and relies on verifable (or ‚Äúrule-based‚Äù) rewards for training. Their r1 model, however, uses a combination of supervised finetuning, RLHF and verifiable rewards. The most fascinating thing about DeepSeek‚Äôs r1 model is reflection or backtracking, where the model can reflect on its own reasoning process and correct itself if it finds a mistake. According to the authors, this emerged during training and was not explicitly programmed into the model.\nData and Objective: The data for verifable rewards is mostly restricted to domains like math and code.\n\nImportance: Reinforcement finetuning for reasoning is a frontier in LLM training with multiple labs trying to understand how best to scale reasoning capabilities.\n\n\n\n\nDespite their impressive capabilities, LLMs have inherent limitations that are crucial to consider when designing applications.\n\n\nLLMs can exhibit prompt sensitivity. Slight variations in prompt phrasing, even while maintaining semantic meaning, can sometimes lead to surprisingly different model outputs. This stochastic nature, combined with the opacity of the training data, makes it challenging to predict model behavior consistently.\nImplications for Applications: Prompt sensitivity poses challenges for building reliable and predictable applications, especially in agentic systems where LLMs make decisions on behalf of users. Inconsistent outputs can undermine user trust and application stability.\nMitigation Strategies:\n\nPrompt Engineering Best Practices: Employing structured prompt formats, clear instructions, adding examples (few shot prompting), chain-of-thought, and consistent phrasing can improve prompt robustness.\nPrompt Testing and Selection: Systematically testing a range of prompts and selecting those that yield the most consistent and desired outputs for a given task. Many ‚Äúobservability‚Äù tools like wandb weave, arize phoenix, langsmith, and claude‚Äôs prompt tuner tools are available to help with this.\nEnsemble Methods: Combining outputs from multiple prompts or model instances can potentially reduce variance and improve robustness, but at a cost.\n\n\n\n\nLLMs can exhibit limited self-improvement. They may repeat the same mistakes or biases without fundamentally learning from their errors in an iterative manner. While models like OpenAI‚Äôs o1 and Claude 3.5 Sonnet demonstrate improved self-correction, particularly in code-related tasks, general self-improvement remains a significant challenge.\n\n\n\nLLMs primarily learn statistical correlations from massive datasets. While they can exhibit impressive ‚Äúknowledge,‚Äù they often lack true ‚Äúunderstanding‚Äù of underlying concepts and causal relationships.\nCounterfactual Reasoning Failures: When tested on counterfactual puzzles or questions that require reasoning about ‚Äúwhat if‚Äù scenarios or understanding causal mechanisms, LLMs often perform poorly. This highlights their reliance on memorized patterns rather than genuine conceptual understanding.\n\n\n\n\nGeneral-purpose LLMs are trained on broad internet datasets. Many specialized domains, such as medicine, law, or specific technical fields, have their own extensive vocabularies, jargon, and conceptual frameworks that are not adequately represented in general language models.\nDomain-Specific Model Requirements: Effective application of LLMs in specialized domains often necessitates:\n\nDomain-Specific Fine-tuning: Further training general LLMs on domain-specific data to adapt their vocabulary and knowledge.\nSpecialized Models: Developing LLMs trained specifically for a particular domain from the outset.\nVocabulary Extension Techniques: Methods to expand the tokenizer vocabulary to include domain-specific terms.\nKnowledge Augmentation: Integrating LLMs with domain-specific knowledge bases or retrieval systems.\n\nConcepts and ideas that appear infrequently in the training data (the ‚Äúlong tail‚Äù of the knowledge distribution) are less likely to be learned effectively by LLMs. While Retrieval-Augmented Generation (RAG) can provide LLMs with relevant context from external knowledge sources, it is not a complete solution for long-tail knowledge. Generating high-quality text about rare or novel concepts may require more ‚Äúcore‚Äù knowledge and reasoning ability than the model possesses, even with retrieved context.\nChallenges for Niche Applications: Applications dealing with highly specialized or niche topics may encounter limitations due to the model‚Äôs lack of familiarity with long-tail concepts.\n\n\n\n\nThis introduction has provided a foundational understanding of Large Language Models. To further your exploration and begin applying LLMs in your projects, consider the following steps:\n\nExplore the Hugging Face Transformers Library: A powerful and user-friendly library for working with pre-trained LLMs in Python. Experiment with different models, tokenizers, and prompting techniques.\nDive into Prompt Engineering: Learn effective prompt engineering strategies to guide LLMs to generate desired outputs. Online resources and courses dedicated to prompt engineering are readily available.\nExperiment with LLM APIs: Utilize APIs from providers like OpenAI, Google, and Anthropic to access and experiment with state-of-the-art LLMs without needing to train or host models yourself.\nInvestigate LLM Application Frameworks: Explore frameworks like LangChain and LlamaIndex that simplify the process of building complex applications with LLMs, including RAG, agents, and more.\nStay Updated with Research: The field of LLMs is rapidly evolving. Follow research publications, blogs, and communities to stay abreast of the latest advancements and emerging techniques.\n\nBy taking these steps, you can move beyond theoretical understanding and begin to practically leverage the power of Large Language Models in your academic research, software development, and beyond."
  },
  {
    "objectID": "posts.html",
    "href": "posts.html",
    "title": "Blog",
    "section": "",
    "text": "Intelligence as a Complex System: Lessons from Physics\n\n\n\n\n\n\nAritifical Intelligence\n\n\nComplex Systems\n\n\nNatural Language Processing\n\n\nLarge Language Models\n\n\n\nUnderstanding Intelligence Through the Lens of Physics\n\n\n\n\n\nJun 15, 2024\n\n\nFarrukh Nauman\n\n\n5 min\n\n\n\n\n\n\n\n\n\n\n\n\nLarge Language Models: A Compact Guide\n\n\n\n\n\n\nApplied AI\n\n\nNatural Language Processing\n\n\nLarge Language Models\n\n\nNotes\n\n\n\nWhat are Large Language Models? What are their limitations and common use cases?\n\n\n\n\n\nNov 20, 2023\n\n\nFarrukh Nauman\n\n\n16 min\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "randomposts/2025-01-31-hf-data-upload/index.html",
    "href": "randomposts/2025-01-31-hf-data-upload/index.html",
    "title": "Uploading datasets to Hugging Face",
    "section": "",
    "text": "Uploading datasets to huggingface turned out to be harder than I initially thought."
  },
  {
    "objectID": "randomposts/2025-01-31-hf-data-upload/index.html#data-formatting",
    "href": "randomposts/2025-01-31-hf-data-upload/index.html#data-formatting",
    "title": "Uploading datasets to Hugging Face",
    "section": "Data formatting",
    "text": "Data formatting\nTo be able to view the dataset in the Hugging Face Datasets Hub, the dataset needs to be formatted in the right way. I had an image classification dataset with several target attributes. I followed the guide here. Here is how I formatted the dataset:\n./\n‚îú‚îÄ‚îÄ train\n‚îÇ   ‚îú‚îÄ‚îÄ metadata.csv\n‚îÇ   ‚îú‚îÄ‚îÄ front_2024_02_29_14_26_45.jpg\n‚îÇ   ‚îú‚îÄ‚îÄ ...\n‚îú‚îÄ‚îÄ test\n‚îÇ   ‚îú‚îÄ‚îÄ metadata.csv\n‚îÇ   ‚îú‚îÄ‚îÄ front_2024_05_30_12_30_02.jpg\n‚îÇ   ‚îú‚îÄ‚îÄ ...\nwhere the metadata.csv file contains the file_name as the first column and several other columns each corresponding to a target attribute. Here is a sample:\nfile_name,brand,usage,condition,type,category,price,trend,colors,cut,pattern,season,text,pilling,damage,stains,holes,smell,material\nfront_2022_12_14_08_48_42.jpg,Junkyard,Export,3,Jeans,Ladies,50-100,Denim,['Blue'],['Loose'],None,Spring,,4,,Minor,None,None,100%cotton\nfront_2023_06_29_08_22_48.jpg,Stacy,Reuse,4,Jeans,Unisex,50-100,None,['Brown'],['Tight'],None,All,,3,,None,None,None,\"98% cotton, 2% elastane\"\nWhen rendered in the dataset viewer in the Hugging Face Datasets Hub, the dataset converts the file_name to an image preview with the title image and retains the other columns. Here is the preview of the dataset:"
  },
  {
    "objectID": "randomposts/2025-01-31-hf-data-upload/index.html#what-worked",
    "href": "randomposts/2025-01-31-hf-data-upload/index.html#what-worked",
    "title": "Uploading datasets to Hugging Face",
    "section": "What worked",
    "text": "What worked\nIn the same image_dataset tutorial, they describe how to upload the dataset using the python command:\n\n\n\n\n\n\nImportant\n\n\n\nload_dataset name is misleading: it is not loading the dataset, but it is really setting up your dataset locally in a format suitable for the data viewer in the Hugging Face Datasets Hub. It should really be called setup_dataset.\n\n\nfrom datasets import load_dataset\n\n# Load the LOCAL folder as a `huggingface/datasets` dataset\ndataset = load_dataset(\"imagefolder\", data_dir=\"./\") # `imagefolder` is a special dataset type that loads images\n\n# Upload the dataset to Hugging Face\ndataset.push_to_hub(\"fnauman/fashion-second-hand-front-only\", private=True) # `private=True` makes the dataset repo private\nI recommend first uploading the dataset as a private dataset to ensure the upload worked and the data preview works as expected. You can later make the dataset public if you wish."
  },
  {
    "objectID": "randomposts/2025-01-31-hf-data-upload/index.html#what-did-not-work",
    "href": "randomposts/2025-01-31-hf-data-upload/index.html#what-did-not-work",
    "title": "Uploading datasets to Hugging Face",
    "section": "What did not work",
    "text": "What did not work\nFollowing the instructions here, I tried using the huggingface-cli command with two variations, but it did not work.\nhuggingface-cli upload fashion-second-hand-front-only . . --repo-type dataset\nhuggingface-cli upload-large-folder fashion-second-hand-front-only --repo-type dataset . --num-workers=8\nBoth of these commands crashed and were relatively slow. I suspect it has to do with the large number of files (30,000) in the dataset."
  }
]